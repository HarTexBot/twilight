<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="twilight-standby"><meta name="keywords" content="rust, rustlang, rust-lang, twilight_standby"><title>twilight_standby - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../twilight_standby/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../twilight_standby/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate twilight_standby</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.11.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></div></section><div id="sidebar-vars" data-name="twilight_standby" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../twilight_standby/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">twilight_standby</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/twilight_standby/lib.rs.html#1-1538">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="twilight-standby"><a href="#twilight-standby">twilight-standby</a></h2>
<p><a href="https://app.codecov.io/gh/twilight-rs/twilight/"><img src="https://img.shields.io/codecov/c/gh/twilight-rs/twilight?logo=codecov&amp;style=for-the-badge&amp;token=E9ERLJL0L2" alt="codecov badge" /></a> <a href="https://discord.gg/7jj8n7D"><img src="https://img.shields.io/discord/745809834183753828?color=%237289DA&amp;label=discord%20server&amp;logo=discord&amp;style=for-the-badge" alt="discord badge" /></a> <a href="https://github.com/twilight-rs/twilight"><img src="https://img.shields.io/badge/github-twilight-6f42c1.svg?style=for-the-badge&amp;logo=github" alt="github badge" /></a> <a href="https://github.com/twilight-rs/twilight/blob/main/LICENSE.md"><img src="https://img.shields.io/badge/license-ISC-blue.svg?style=for-the-badge&amp;logo=pastebin" alt="license badge" /></a> <img src="https://img.shields.io/badge/rust-1.60+-93450a.svg?style=for-the-badge&amp;logo=rust" alt="rust badge" /></p>
<p>Standby is a utility to wait for an event to happen based on a predicate
check. For example, you may have a command that has a reaction menu of ✅
and ❌. If you want to handle a reaction to these, using something like an
application-level state or event stream may not suit your use case. It may
be cleaner to wait for a reaction inline to your function. This is where
Twilight Standby comes in.</p>
<p>Standby allows you to wait for things like an event in a certain guild
(<a href="struct.Standby.html#method.wait_for" title="Standby::wait_for"><code>Standby::wait_for</code></a>), a new message in a channel
(<a href="struct.Standby.html#method.wait_for_message" title="Standby::wait_for_message"><code>Standby::wait_for_message</code></a>), a new reaction on a message
(<a href="struct.Standby.html#method.wait_for_reaction" title="Standby::wait_for_reaction"><code>Standby::wait_for_reaction</code></a>), and any event that might not take place in
a guild, such as a new <code>Ready</code> event (<a href="struct.Standby.html#method.wait_for_event" title="Standby::wait_for_event"><code>Standby::wait_for_event</code></a>). Each
method also has a stream variant.</p>
<p>To use Standby it must process events, such as in an event loop of events
received by the gateway. Check out the <a href="struct.Standby.html#method.process" title="Standby::process"><code>Standby::process</code></a> method.</p>
<h3 id="when-to-use-futures-and-streams"><a href="#when-to-use-futures-and-streams">When to use futures and streams</a></h3>
<p><a href="struct.Standby.html" title="Standby"><code>Standby</code></a> has two variants of each method: a future variant and a stream
variant. An example is <a href="struct.Standby.html#method.wait_for_message" title="Standby::wait_for_message"><code>Standby::wait_for_message</code></a>, which also has a
<a href="struct.Standby.html#method.wait_for_message_stream" title="Standby::wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> variant. The future variant is useful
when you want to oneshot an event that you need to wait for. This means that
if you only need to wait for one message in a channel to come in, you’d use
the future variant. If you need to wait for multiple messages, such as maybe
all of the messages within a minute’s timespan, you’d use the
<a href="struct.Standby.html#method.wait_for_message_stream" title="Standby::wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> method.</p>
<p>The difference is that if you use the futures variant in a loop then you may
miss some events while processing a received event. By using a stream, you
won’t miss any events.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3><h4 id="at-a-glance"><a href="#at-a-glance">At a glance</a></h4>
<p>Wait for a message in channel 123 by user 456 with the content “test”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">twilight_model</span>::{
    <span class="ident">gateway::payload::incoming::MessageCreate</span>,
    <span class="ident">id::Id</span>,
};
<span class="kw">use</span> <span class="ident">twilight_standby::Standby</span>;

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std::error::Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">standby</span> <span class="op">=</span> <span class="ident">Standby::new</span>();

    <span class="kw">let</span> <span class="ident">channel_id</span> <span class="op">=</span> <span class="ident">Id::new</span>(<span class="number">123</span>);

    <span class="kw">let</span> <span class="ident">message</span> <span class="op">=</span> <span class="ident">standby</span>.<span class="ident">wait_for_message</span>(<span class="ident">channel_id</span>, <span class="op">|</span><span class="ident">event</span>: <span class="kw-2">&amp;</span><span class="ident">MessageCreate</span><span class="op">|</span> {
        <span class="ident">event</span>.<span class="ident">author</span>.<span class="ident">id</span>.<span class="ident">get</span>() <span class="op">==</span> <span class="number">456</span> <span class="op">&amp;&amp;</span> <span class="ident">event</span>.<span class="ident">content</span> <span class="op">==</span> <span class="string">&quot;test&quot;</span>
    }).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="a-full-example"><a href="#a-full-example">A full example</a></h4>
<p>A full sample bot connecting to the gateway, processing events, and
including a handler to wait for reactions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">futures_util::StreamExt</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">env</span>, <span class="ident">sync::Arc</span>};
<span class="kw">use</span> <span class="ident">twilight_gateway</span>::{<span class="ident">Event</span>, <span class="ident">Intents</span>, <span class="ident">Shard</span>};
<span class="kw">use</span> <span class="ident">twilight_model</span>::{
    <span class="ident">channel::Message</span>,
    <span class="ident">gateway::payload::incoming::ReactionAdd</span>,
};
<span class="kw">use</span> <span class="ident">twilight_standby::Standby</span>;

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">token</span> <span class="op">=</span> <span class="ident">env::var</span>(<span class="string">&quot;DISCORD_TOKEN&quot;</span>)<span class="question-mark">?</span>;

    <span class="comment">// Start a shard connected to the gateway to receive events.</span>
    <span class="kw">let</span> <span class="ident">intents</span> <span class="op">=</span> <span class="ident">Intents::GUILD_MESSAGES</span> <span class="op">|</span> <span class="ident">Intents::GUILD_MESSAGE_REACTIONS</span>;
    <span class="kw">let</span> (<span class="ident">shard</span>, <span class="kw-2">mut</span> <span class="ident">events</span>) <span class="op">=</span> <span class="ident">Shard::new</span>(<span class="ident">token</span>, <span class="ident">intents</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="ident">shard</span>.<span class="ident">start</span>().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">let</span> <span class="ident">standby</span> <span class="op">=</span> <span class="ident">Arc::new</span>(<span class="ident">Standby::new</span>());

    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">event</span>) <span class="op">=</span> <span class="ident">events</span>.<span class="ident">next</span>().<span class="kw">await</span> {
        <span class="comment">// Have standby process the event, which will fulfill any futures</span>
        <span class="comment">// that are waiting for an event.</span>
        <span class="ident">standby</span>.<span class="ident">process</span>(<span class="kw-2">&amp;</span><span class="ident">event</span>);

        <span class="kw">match</span> <span class="ident">event</span> {
            <span class="ident">Event::MessageCreate</span>(<span class="ident">msg</span>) <span class="kw">if</span> <span class="ident">msg</span>.<span class="ident">content</span> <span class="op">==</span> <span class="string">&quot;!react&quot;</span> =&gt; {
                <span class="ident">tokio::spawn</span>(<span class="ident">react</span>(<span class="ident">msg</span>.<span class="number">0</span>, <span class="ident">Arc::clone</span>(<span class="kw-2">&amp;</span><span class="ident">standby</span>)));
            },
            <span class="kw">_</span> =&gt; {},
        }
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="comment">// Wait for a reaction from the user who sent the message, and then print it</span>
<span class="comment">// once they react.</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">react</span>(<span class="ident">msg</span>: <span class="ident">Message</span>, <span class="ident">standby</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">Standby</span><span class="op">&gt;</span>) -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">author_id</span> <span class="op">=</span> <span class="ident">msg</span>.<span class="ident">author</span>.<span class="ident">id</span>;

    <span class="kw">let</span> <span class="ident">reaction</span> <span class="op">=</span> <span class="ident">standby</span>.<span class="ident">wait_for_reaction</span>(<span class="ident">msg</span>.<span class="ident">id</span>, <span class="kw">move</span> <span class="op">|</span><span class="ident">event</span>: <span class="kw-2">&amp;</span><span class="ident">ReactionAdd</span><span class="op">|</span> {
        <span class="ident">event</span>.<span class="ident">user_id</span> <span class="op">==</span> <span class="ident">author_id</span>
    }).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;user reacted with {:?}&quot;</span>, <span class="ident">reaction</span>.<span class="ident">emoji</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>For more examples, check out each of the methods on <a href="struct.Standby.html" title="Standby"><code>Standby</code></a>.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="future/index.html" title="twilight_standby::future mod">future</a></div><div class="item-right docblock-short"><p>Futures and streams returned by <a href="struct.Standby.html"><code>Standby</code></a>.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ProcessResults.html" title="twilight_standby::ProcessResults struct">ProcessResults</a></div><div class="item-right docblock-short"><p>Number of <a href="struct.Standby.html" title="Standby"><code>Standby</code></a> calls that were completed.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Standby.html" title="twilight_standby::Standby struct">Standby</a></div><div class="item-right docblock-short"><p>The <code>Standby</code> struct, used by the main event loop to process events and by
tasks to wait for an event.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="twilight_standby" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0-nightly (bb8c2f411 2022-06-19)" ></div>
</body></html>